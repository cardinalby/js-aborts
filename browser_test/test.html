<!DOCTYPE html>
<html lang="en">
<head>
    <!--
        Didn't want to bring heavy browser testing tools so the AI reimplemented the tests for manual browser testing
    -->
    <meta charset="UTF-8">
    <title>Browser test</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; }
        .test { margin-bottom: 8px; }
        .name { font-weight: 600; }
        .pass { color: green; }
        .fail { color: red; }
        pre { background:#f6f8fa; padding:8px; border-radius:6px; overflow:auto }
    </style>
</head>
<body>
<h1>Browser Tests</h1>
<div id="results"></div>

<script type="module">
import { aborts } from '../dist/index.js'

function logResult(name, ok, details) {
    const container = document.getElementById('results')
    const div = document.createElement('div')
    div.className = 'test'
    const status = document.createElement('span')
    status.className = ok ? 'pass' : 'fail'
    status.textContent = ok ? 'PASS' : 'FAIL'
    const title = document.createElement('span')
    title.className = 'name'
    title.textContent = ' ' + name
    div.appendChild(status)
    div.appendChild(title)
    if (details) {
        const pre = document.createElement('pre')
        pre.textContent = details
        div.appendChild(pre)
    }
    container.appendChild(div)
}

function delay(ms) {
    return new Promise(res => setTimeout(res, ms))
}

async function run() {
    // Group: aborts.create
    try {
        // test: propagates parent abort to child
        {
            const parent = new AbortController()
            const child = aborts.create(parent.signal)

            if (child.signal.aborted) throw new Error('child aborted initially')

            const reasons = []
            child.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))

            parent.abort('parent-reason')
            await Promise.resolve()

            if (!child.signal.aborted) throw new Error('child not aborted after parent')
            if (reasons.length === 0) throw new Error('no abort reasons forwarded')
            if (reasons[0] !== 'parent-reason') throw new Error('reason not forwarded')
            child.abort('another-reason')
            if (reasons.length !== 1) throw new Error('abort called twice on child')
        }
        logResult('aborts.create: propagates parent abort to child', true)
    } catch (err) {
        logResult('aborts.create: propagates parent abort to child', false, String(err))
    }

    try {
        // test: returns no-op controller when parent already aborted
        const parent = new AbortController()
        parent.abort('already')
        const child = aborts.create(parent.signal)
        if (!child.signal.aborted) throw new Error('child not aborted')
        if (child.signal.reason !== 'already') throw new Error('reason mismatch')
        // calling abort on returned controller should be no-op
        child.abort('another')
        if (child.signal.reason !== 'already') throw new Error('abort changed reason')
        logResult('aborts.create: returns no-op controller when parent already aborted', true)
    } catch (err) {
        logResult('aborts.create: returns no-op controller when parent already aborted', false, String(err))
    }

    try {
        // test: undefined parent
        const child = aborts.create(undefined)
        if (child.signal.aborted) throw new Error('child aborted initially')
        const reasons = []
        child.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))
        child.abort('manual-abort')
        await Promise.resolve()
        if (!child.signal.aborted) throw new Error('child not aborted after manual abort')
        if (reasons.length === 0) throw new Error('no reasons')
        if (reasons[0] !== 'manual-abort') throw new Error('reason mismatch')
        logResult('aborts.create: undefined parent', true)
    } catch (err) {
        logResult('aborts.create: undefined parent', false, String(err))
    }

    try {
        // test: parent is not aborted when child aborts
        const parent = new AbortController()
        const child = aborts.create(parent.signal)
        if (child.signal.aborted) throw new Error('child aborted initially')
        if (parent.signal.aborted) throw new Error('parent aborted initially')
        child.abort('child-abort')
        if (!child.signal.aborted) throw new Error('child not aborted')
        if (child.signal.reason !== 'child-abort') throw new Error('child reason mismatch')
        if (parent.signal.aborted) throw new Error('parent was aborted by child')
        logResult('aborts.create: parent is not aborted', true)
    } catch (err) {
        logResult('aborts.create: parent is not aborted', false, String(err))
    }

    try {
        // test: is compatible with native AbortController
        const parent = new AbortController()
        if (!(parent instanceof AbortController)) throw new Error('parent not instance of AbortController')
        parent.abort('parent-abort')
        const child = aborts.create(parent.signal)
        if (!(child instanceof AbortController)) throw new Error('child not instance of AbortController')
        logResult('aborts.create: is compatible with native AbortController', true)
    } catch (err) {
        logResult('aborts.create: is compatible with native AbortController', false, String(err))
    }

    try {
        // test: is disposable
        let ac
        (function(){
            const ac2 = aborts.create()
            ac = ac2
            if (ac2.signal.aborted) throw new Error('ac2 aborted initially')
            // simulate using-block by calling dispose if provided
            if (typeof Symbol !== 'undefined' && typeof Symbol.dispose !== 'undefined' && ac2[Symbol.dispose]) {
                ac2[Symbol.dispose]()
            } else {
                // fallback: call abort
                ac2.abort()
            }
        })()
        if (!ac.signal.aborted) throw new Error('ac not aborted after dispose')
        logResult('aborts.create: is disposable', true)
    } catch (err) {
        logResult('aborts.create: is disposable', false, String(err))
    }

    // Group: aborts.timeout
    try {
        // helper to get native timeout error
        const getNativeTimeoutError = async () => {
            const s = AbortSignal.timeout(0)
            await delay(0)
            return s.reason
        }

        // test: aborts after timeout
        const timeoutMs = 100
        {
            const controller = aborts.timeout(timeoutMs)
            if (controller.signal.aborted) throw new Error('controller aborted initially')
            const reasons = []
            controller.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))
            await delay(50)
            if (controller.signal.aborted) throw new Error('aborted too early')
            await delay(100)
            if (!controller.signal.aborted) throw new Error('not aborted after timeout')
            const nativeErr = await getNativeTimeoutError()
            if (reasons.length === 0) throw new Error('no reasons')
            // compare name and message where possible
            if (String(reasons[0]) !== String(nativeErr)) {
                // best effort check: check name
                if (reasons[0]?.name !== nativeErr?.name) throw new Error('timeout error name mismatch')
            }
            controller.abort('another-reason')
            if (reasons.length !== 1) throw new Error('abort called twice after timeout')
        }
        logResult('aborts.timeout: aborts after timeout', true)
    } catch (err) {
        logResult('aborts.timeout: aborts after timeout', false, String(err))
    }

    try {
        // test: negative timeout
        const timeoutMs = -1000
        {
            const controller = aborts.timeout(timeoutMs)
            if (!controller.signal.aborted) throw new Error('controller not aborted for negative timeout')
            // reason should be timeout-like
            // can't rely on exact object, just ensure there's a reason
            if (typeof controller.signal.reason === 'undefined') throw new Error('no reason')
        }
        logResult('aborts.timeout: negative timeout', true)
    } catch (err) {
        logResult('aborts.timeout: negative timeout', false, String(err))
    }

    try {
        // test: negative timeout with cancelled parent
        const parent = new AbortController()
        parent.abort('parent-abort')
        const timeoutMs = -1000
        const controller = aborts.timeout(timeoutMs, parent.signal)
        if (!controller.signal.aborted) throw new Error('controller not aborted')
        if (controller.signal.reason !== 'parent-abort') throw new Error('reason not forwarded from parent')
        controller.abort('another-abort')
        if (controller.signal.reason !== 'parent-abort') throw new Error('abort changed reason')
        logResult('aborts.timeout: negative timeout with cancelled parent', true)
    } catch (err) {
        logResult('aborts.timeout: negative timeout with cancelled parent', false, String(err))
    }

    try {
        // test: undefined parent
        const controller = aborts.timeout(1000, undefined)
        if (controller.signal.aborted) throw new Error('controller aborted initially')
        const reasons = []
        controller.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))
        controller.abort('manual-abort')
        await Promise.resolve()
        if (!controller.signal.aborted) throw new Error('not aborted after manual abort')
        if (reasons.length === 0) throw new Error('no reasons')
        if (reasons[0] !== 'manual-abort') throw new Error('reason mismatch')
        await delay(1100)
        if (!controller.signal.aborted) throw new Error('lost aborted state after timeout')
        if (reasons.length !== 1) throw new Error('reasons changed after timeout')
        logResult('aborts.timeout: undefined parent', true)
    } catch (err) {
        logResult('aborts.timeout: undefined parent', false, String(err))
    }

    try {
        // test: propagates parent abort to child
        const parent = new AbortController()
        const child = aborts.timeout(5000, parent.signal)
        if (child.signal.aborted) throw new Error('child aborted initially')
        const reasons = []
        child.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))
        parent.abort('parent-reason')
        await Promise.resolve()
        if (!child.signal.aborted) throw new Error('child not aborted after parent')
        if (reasons.length === 0) throw new Error('no reason forwarded')
        if (reasons[0] !== 'parent-reason') throw new Error('reason mismatch')
        logResult('aborts.timeout: propagates parent abort to child', true)
    } catch (err) {
        logResult('aborts.timeout: propagates parent abort to child', false, String(err))
    }

    try {
        // test: returns no-op controller when parent already aborted
        const parent = new AbortController()
        parent.abort('already')
        const child = aborts.timeout(1000, parent.signal)
        if (!child.signal.aborted) throw new Error('child not aborted')
        if (child.signal.reason !== 'already') throw new Error('reason mismatch')
        child.abort('another')
        if (child.signal.reason !== 'already') throw new Error('abort changed reason')
        logResult('aborts.timeout: returns no-op controller when parent already aborted', true)
    } catch (err) {
        logResult('aborts.timeout: returns no-op controller when parent already aborted', false, String(err))
    }

    try {
        // test: explicit abort before timeout
        const controller = aborts.timeout(500)
        if (controller.signal.aborted) throw new Error('controller aborted initially')
        const reasons = []
        controller.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))
        controller.abort('manual-abort')
        await Promise.resolve()
        if (!controller.signal.aborted) throw new Error('controller not aborted after manual abort')
        if (reasons.length === 0) throw new Error('no reasons')
        if (reasons[0] !== 'manual-abort') throw new Error('reason mismatch')
        await delay(600)
        if (!controller.signal.aborted) throw new Error('lost aborted state after timeout')
        if (reasons.length !== 1) throw new Error('reasons changed after timeout')
        logResult('aborts.timeout: explicit abort before timeout', true)
    } catch (err) {
        logResult('aborts.timeout: explicit abort before timeout', false, String(err))
    }

    try {
        // test: parent aborts before timeout
        const parent = new AbortController()
        const child = aborts.timeout(5000, parent.signal)
        if (child.signal.aborted) throw new Error('child aborted initially')
        const reasons = []
        child.signal.addEventListener('abort', (ev) => reasons.push(ev.target.reason))
        parent.abort('parent-reason')
        await Promise.resolve()
        if (!child.signal.aborted) throw new Error('child not aborted after parent')
        if (reasons.length === 0) throw new Error('no reason forwarded')
        if (reasons[0] !== 'parent-reason') throw new Error('reason mismatch')
        logResult('aborts.timeout: parent aborts before timeout', true)
    } catch (err) {
        logResult('aborts.timeout: parent aborts before timeout', false, String(err))
    }

    try {
        // test: parent is not aborted when child aborts
        const parent = new AbortController()
        const child = aborts.timeout(5000, parent.signal)
        if (child.signal.aborted) throw new Error('child aborted initially')
        if (parent.signal.aborted) throw new Error('parent aborted initially')
        child.abort('child-abort')
        if (!child.signal.aborted) throw new Error('child not aborted')
        if (child.signal.reason !== 'child-abort') throw new Error('child reason mismatch')
        if (parent.signal.aborted) throw new Error('parent was aborted by child')
        logResult('aborts.timeout: parent is not aborted', true)
    } catch (err) {
        logResult('aborts.timeout: parent is not aborted', false, String(err))
    }

    try {
        // test: is compatible with native AbortController
        const parent = new AbortController()
        if (!(parent instanceof AbortController)) throw new Error('parent not instance of AbortController')
        parent.abort('parent-abort')
        const child = aborts.timeout(0, parent.signal)
        if (!(child instanceof AbortController)) throw new Error('child not instance of AbortController')
        logResult('aborts.timeout: is compatible with native AbortController', true)
    } catch (err) {
        logResult('aborts.timeout: is compatible with native AbortController', false, String(err))
    }

    try {
        // test: is disposable
        let ac
        (function(){
            const ac2 = aborts.timeout(5000)
            ac = ac2
            if (ac2.signal.aborted) throw new Error('ac2 aborted initially')
            if (typeof Symbol !== 'undefined' && typeof Symbol.dispose !== 'undefined' && ac2[Symbol.dispose]) {
                ac2[Symbol.dispose]()
            } else {
                ac2.abort()
            }
        })()
        if (!ac.signal.aborted) throw new Error('ac not aborted after dispose')
        logResult('aborts.timeout: is disposable', true)
    } catch (err) {
        logResult('aborts.timeout: is disposable', false, String(err))
    }

    // write message that all tests are done
    const container = document.getElementById('results')
    const div = document.createElement('div')
    div.style.marginTop = '16px'
    div.style.fontWeight = '600'
    div.textContent = 'All tests done.'
    container.appendChild(div)
}

run()
    .catch(err => {
        logResult('runner', false, String(err))
    })
</script>
</body>
</html>